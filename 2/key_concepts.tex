\section{KEY CONCEPTS} % (fold)
\label{sec:key_concepts}
This section discusses several key concepts of Continuous Integration that particularly pertain to the automation of workflows. These concepts are referenced from Martin Fowler's webpage, the originator of Continuous Integration. 

\subsection{Maintain a Single Source Repository} % (fold)
\label{sub:maintain_a_single_source_repository}
For a given software project, there is a huge variety of source files that need to interact with each other to build the final product. Continuous Integration dictates that the team should have a single source repository, where all the source files should be stored.  These source files should include any properties files and settings so that any fresh development system should be able to retrieve all the files from the repository and be able to build right away.\newline

The same thinking should be applied to any complex workflow, such as the software workflow. The software workflow includes many parts: Java source files, XSLT transformation documents, XSD schema documents, properties files, input files, the resulting output files and most importantly, the automation script. For the automation - a script in this case - to find all the necessary parts, they should all be accumulated in a single repository. This allows the workflow to look in a single place for any information or feedback that it requires and any changes to the workflow only need to be changed from one location.  There leaves no chance for error in forgetting to modify many locations at the same time. This also applies to the physical workflow in the sense that the toy manufacturing plant should have all the necessary parts stored in a single repository - the warehouse.
% subsection maintain_a_single_source_repository (end)

\subsection{Make Your Build Self-Testing} % (fold)
\label{sub:make_your_build_self_testing}
In software development, a build usually consists of a number of steps including linking the source to any source dependancies and running the source through a compiler. Though many modern high-level computer languages such as Java or C++ have compilers that catch many bugs, many are still remain in the code for various reasons. Continuous Integration recommends automated testing as a highly efficient method of catching these remaining bugs. These tests would be inserted into the automated build process and any failed tests should be reflected as a failed build. This allows for all source code that is produced to be run through a minimum number of basic tests before being allowed to go through to deployment.\newline

As an application to workflows in general, this means that the workflow needs to be able to give feedback on its progress and be able to utilize that feedback accordingly. This can be simply applied to the software workflow by setting up the build process to check the results at all main checkpoints.  If any of the checkpoints fail, then the whole build would fail and an email would be sent notifying the data steward of the error. Under certain circumstances, the lead developer would also be notified of the issue, so that they may inspect the workflow and the build itself to see if there are any problems. Such a system is also possible for the physical workflow, a number of quality control tests could be performed by computers. Should any toys fail the automated quality control measures, they would automatically be discarded. Thus each and every toy is guaranteed to be tested and at a certain standard prior to any human interaction.
% subsection make_your_build_self_testing (end)

\subsection{Keep the Build Fast} % (fold)
\label{sub:keep_the_build_fast}
As a project grows, its build quickly becomes more complicated. As the build becomes more complicated, it becomes increasingly important that the build itself does not become the longest and most time-consuming part of development. This means that the build itself must be streamlined to perform faster. There are also other methods that allow for a quicker build, but this speed comes at the cost of decreased bug-detection. The recommended method is to set up a ``staged build'', otherwise known as a ``build pipeline''.  The basic idea is that the commit build - the build required to commit so others can start working on the new source files - is the first stage. This stage must be completed as fast as possible, allowing for some bugs to possibly slip through.  The second stage consists of testing of the latest committed build, this is also known as a ``secondary build''.  These tests run all the extra tests for bugs that would otherwise not be considered harmful enough to fail the commit build.  New tests are added whenever the ``secondary build'' fails so that the same bug does not appear again. This allows for the build speed to keep pace with development, and not slow it down, while strengthening the build and testing system. Depending on the number and magnitude of the tests in the ``secondary build'', a number of computers may be used in parallel to hasten the process.\newline

This concept goes into the prioritization and parallelization of tasks. First the workflow must be reconsidered to see if all the steps are essential to process. Should any steps be deemed not entirely necessary for a first rough product, then that step should be refactored into a secondary process that runs in the background. Secondly any steps that could be completed in parallel should be completed at the same time. This saves a lot of time, increasing efficiency. For example, in the software workflow, all steps are mandatory to a successful final product, however many of these same workflows need to be run one after another to deal with numerous different input files. If each of these workflows could be initiated at the same time, then a significant increase in throughput would occur. Even if only three or four workflows could be initiated at the same time, the total number of workflows would be completed three or four times faster without a major increase in resources. The same principle of parallelization could also be applied to physical workflows in the sense that the toy could have the top and bottom half produced at the same time with a machine that joins them in the end. This adds a piece of machinery, an additional cost, but doubles the speed of production. In these cases, prioritization cannot be applied, as all steps are required in these cases and none could be refactored to a secondary process.
% subsection keep_the_build_fast (end)

% section key_concepts (end)